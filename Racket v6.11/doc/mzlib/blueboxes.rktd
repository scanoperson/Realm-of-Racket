9096
((3) 0 () 20 ((q lib "mzlib/contract.rkt") (q lib "mzlib/compat.rkt") (q lib "mzlib/list.rkt") (q submod (lib "racket/unit.rkt") compat) (q lib "mzlib/etc.rkt") (q lib "mzlib/kw.rkt") (q lib "mzlib/pconvert.rkt") (q lib "mzlib/os.rkt") (q lib "mzlib/include.rkt") (q lib "mzlib/struct.rkt") (q lib "mzlib/pregexp.rkt") (q lib "mzlib/match.rkt") (q lib "mzlib/pconvert-prop.rkt") (q lib "mzlib/cml.rkt") (q lib "mzlib/thread.rkt") (q lib "mzlib/awk.rkt") (q lib "mzlib/serialize.rkt") (q lib "mzlib/string.rkt") (q lib "mzlib/file.rkt") (q lib "mzlib/transcr.rkt")) () (h ! (equal) ((c def c (c (? . 7) q gethostname)) q (12572 . 2)) ((c def c (c (? . 1) q putprop)) q (3847 . 5)) ((c def c (c (? . 0) q vector/c)) q (4256 . 3)) ((c form c (c (? . 16) q define-serializable-struct)) q (20575 . 2)) ((c def c (c (? . 2) q mergesort)) q (11581 . 4)) ((c form c (c (? . 8) q include-at/relative-to)) q (9353 . 2)) ((c form c (c (? . 3) q struct~r/ctc)) q (24539 . 2)) ((c def c (c (? . 0) q vectorof)) q (4187 . 3)) ((c form c (c (? . 0) q opt->)) q (4760 . 3)) ((c form c (c (? . 0) q ->*)) q (4598 . 6)) ((c def c (c (? . 1) q <=?)) q (3072 . 3)) ((c def c (c (? . 2) q eighth)) q (11266 . 3)) ((c def c (c (? . 18) q call-with-output-file*)) q (8008 . 11)) ((c form c (c (? . 4) q recur)) q (7467 . 2)) ((c def c (c (? . 13) q spawn)) q (2517 . 3)) ((c form c (c (? . 3) q struct~s/ctc)) q (24575 . 2)) ((c form c (c (? . 4) q this-expression-source-directory)) q (7610 . 3)) ((c def c (c (? . 17) q string-uppercase!)) q (21769 . 3)) ((c form c (c (? . 5) q lambda/kw)) q (9541 . 2)) ((c form c (c (? . 5) q define/kw)) q (9584 . 32)) ((q def ((lib "mzlib/math.rkt") e)) q (12554 . 2)) ((q form ((lib "mzlib/plt-match.rkt") define-match-expander)) q (15992 . 4)) ((c def c (c (? . 1) q new-cafe)) q (3965 . 3)) ((c def c (c (? . 2) q sixth)) q (11138 . 3)) ((c def c (c (? . 1) q atom?)) q (3503 . 3)) ((c def c (c (? . 0) q build-flat-contract)) q (4384 . 4)) ((c def c (c (? . 1) q 1-)) q (3231 . 3)) ((c def c (c (? . 6) q booleans-as-true/false)) q (12903 . 4)) ((c def c (c (? . 1) q real-time)) q (3461 . 2)) ((c form c (c (? . 1) q define-structure)) q (3549 . 4)) ((c form c (c (? . 4) q this-expression-file-name)) q (7694 . 3)) ((c def c (c (? . 2) q quicksort)) q (11698 . 4)) ((c form c (c (? . 4) q define-syntax-set)) q (6616 . 2)) ((c def c (c (? . 6) q print-convert-expr)) q (14992 . 7)) ((c def c (c (? . 7) q truncate-file)) q (12648 . 4)) ((c form c (c (? . 0) q ->d*)) q (5127 . 3)) ((c def c (c (? . 15) q match:substring)) q (1511 . 4)) ((c def c (c (? . 6) q add-make-prefix-to-constructor)) q (13345 . 4)) ((c def c (c (? . 10) q pregexp-match)) q (16225 . 15)) ((q form ((lib "mzlib/cmdline.rkt") command-line)) q (1742 . 21)) ((c def c (c (? . 2) q last-pair)) q (11377 . 3)) ((c form c (c (? . 8) q include/reader)) q (9493 . 2)) ((c def c (c (? . 6) q show-sharing)) q (15319 . 4)) ((c form c (c (? . 4) q hash-table)) q (7764 . 2)) ((q def ((lib "mzlib/port.rkt") strip-shell-command-start)) q (16149 . 3)) ((c def c (c (? . 6) q constructor-style-printing)) q (13538 . 4)) ((c form c (c (? . 4) q opt-lambda)) q (7426 . 2)) ((c def c (c (? . 4) q namespace-defined?)) q (7307 . 3)) ((c form c (c (? . 3) q struct/ctc)) q (24348 . 7)) ((c def c (c (? . 1) q <?)) q (2964 . 3)) ((c form c (c (? . 11) q match)) q (11815 . 5)) ((c def c (c (? . 14) q run-server)) q (23178 . 21)) ((c def c (c (? . 12) q prop:print-converter)) q (15551 . 2)) ((c def c (c (? . 6) q whole/fractional-exact-numbers)) q (15411 . 4)) ((c form c (c (? . 9) q define-struct/properties)) q (22758 . 7)) ((c form c (c (? . 9) q copy-struct)) q (22656 . 3)) ((c form c (c (? . 0) q ->d)) q (5067 . 2)) ((c def c (c (? . 10) q pregexp-replace*)) q (18395 . 7)) ((c def c (c (? . 1) q flush-output-port)) q (3366 . 3)) ((c def c (c (? . 6) q current-read-eval-convert-print-prompt)) q (14532 . 4)) ((c form c (c (? . 0) q case->)) q (6402 . 2)) ((c form c (c (? . 8) q include)) q (9125 . 10)) ((c form c (c (? . 0) q object-contract)) q (6459 . 2)) ((c def c (c (? . 2) q seventh)) q (11201 . 3)) ((c form c (c (? . 4) q begin-with-definitions)) q (6565 . 2)) ((c form c (c (? . 0) q ->)) q (4509 . 3)) ((c form c (c (? . 11) q match-define)) q (12209 . 2)) ((c def c (c (? . 4) q identity)) q (6805 . 3)) ((c def c (c (? . 12) q print-converter-proc)) q (15649 . 4)) ((c def c (c (? . 13) q channel-recv-evt)) q (2613 . 3)) ((c def c (c (? . 6) q install-converting-printer)) q (14824 . 2)) ((c def c (c (? . 6) q current-build-share-hook)) q (13682 . 7)) ((c form c (c (? . 0) q ->r)) q (5266 . 7)) ((c form c (c (? . 4) q nand)) q (7377 . 2)) ((c form c (c (? . 9) q make-->vector)) q (23027 . 2)) ((c def c (c (? . 13) q current-time)) q (2820 . 2)) ((c def c (c (? . 14) q consumer-thread)) q (23061 . 4)) ((c def c (c (? . 1) q >?)) q (3018 . 3)) ((c form c (c (? . 4) q nor)) q (7402 . 2)) ((c def c (c (? . 2) q first)) q (10836 . 3)) ((c def c (c (? . 15) q regexp-exec)) q (1630 . 4)) ((c def c (c (? . 6) q current-print-convert-hook)) q (14153 . 8)) ((c form c (c (? . 16) q define-serializable-struct/versions)) q (20666 . 13)) ((c def c (c (? . 17) q read-from-string)) q (22166 . 6)) ((c form c (c (? . 3) q struct)) q (24194 . 7)) ((c def c (c (? . 2) q second)) q (10884 . 3)) ((c form c (c (? . 0) q opt->*)) q (4909 . 3)) ((c def c (c (? . 13) q thread-done-evt)) q (2758 . 3)) ((c def c (c (? . 12) q prop:print-convert-constructor-name)) q (15765 . 2)) ((c def c (c (? . 12) q print-convert-named-constructor?)) q (15821 . 3)) ((c def c (c (? . 11) q match-equality-test)) q (12399 . 4)) ((c form c (c (? . 8) q include-at/relative-to/reader)) q (9413 . 2)) ((c form c (c (? . 11) q match-let*)) q (12103 . 2)) ((c def c (c (? . 6) q print-convert)) q (14874 . 4)) ((c form c (c (? . 0) q struct/c)) q (4330 . 2)) ((c def c (c (? . 10) q pregexp-split)) q (17657 . 9)) ((c def c (c (? . 13) q channel)) q (2579 . 2)) ((c def c (c (? . 2) q third)) q (10948 . 3)) ((c def c (c (? . 4) q loop-until)) q (7128 . 6)) ((c def c (c (? . 6) q build-share)) q (13485 . 3)) ((c def c (c (? . 1) q getprop)) q (3716 . 5)) ((c form c (c (? . 3) q struct~r)) q (24523 . 2)) ((c form c (c (? . 0) q ->pp-rest)) q (5830 . 13)) ((c def c (c (? . 2) q rest)) q (11330 . 3)) ((c form c (c (? . 11) q define/match)) q (11925 . 2)) ((c def c (c (? . 18) q build-relative-path)) q (8456 . 7)) ((c def c (c (? . 6) q named/undefined-handler)) q (13188 . 4)) ((c form c (c (? . 11) q match-lambda)) q (11981 . 2)) ((c def c (c (? . 19) q transcript-on)) q (24090 . 3)) ((c form c (c (? . 3) q struct~s)) q (24559 . 2)) ((c def c (c (? . 15) q match:end)) q (1379 . 4)) ((q def ((lib "mzlib/restart.rkt") restart-mzscheme)) q (18715 . 9)) ((c form c (c (? . 11) q match-letrec)) q (12155 . 2)) ((c def c (c (? . 2) q merge-sorted-lists)) q (11429 . 5)) ((c def c (c (? . 6) q abbreviate-cons-as-list)) q (12777 . 4)) ((c def c (c (? . 1) q 1+)) q (3182 . 3)) ((c form c (c (? . 11) q match-let)) q (12052 . 2)) ((c def c (c (? . 17) q expr->string)) q (22103 . 3)) ((c def c (c (? . 13) q time-evt)) q (2856 . 3)) ((c form c (c (? . 4) q rec)) q (7508 . 4)) ((c def c (c (? . 17) q read-from-string-all)) q (22409 . 6)) ((c def c (c (? . 6) q current-build-share-name-hook)) q (13959 . 5)) ((c def c (c (? . 7) q getpid)) q (12609 . 2)) ((c def c (c (? . 10) q pregexp-replace)) q (18076 . 7)) ((c def c (c (? . 5) q keyword-get)) q (10685 . 5)) ((c form c (c (? . 11) q define-match-expander)) q (12242 . 4)) ((c form c (c (? . 15) q awk)) q (0 . 38)) ((c def c (c (? . 6) q quasi-read-style-printing)) q (15205 . 4)) ((c form c (c (? . 0) q define/contract)) q (4060 . 2)) ((c def c (c (? . 15) q match:start)) q (1245 . 4)) ((c def c (c (? . 17) q glob->regexp)) q (21272 . 10)) ((c form c (c (? . 4) q begin-lifted)) q (6531 . 2)) ((c def c (c (? . 2) q fifth)) q (11075 . 3)) ((c def c (c (? . 6) q use-named/undefined-handler)) q (13023 . 4)) ((c def c (c (? . 6) q get-shared)) q (14673 . 5)) ((c def c (c (? . 13) q channel-send-evt)) q (2676 . 4)) ((c def c (c (? . 1) q >=?)) q (3127 . 3)) ((c form c (c (? . 0) q ->pp)) q (5469 . 11)) ((c def c (c (? . 12) q print-converter?)) q (15592 . 3)) ((c def c (c (? . 1) q gentmp)) q (3280 . 3)) ((c def c (c (? . 18) q build-absolute-path)) q (8752 . 8)) ((c def c (c (? . 2) q fourth)) q (11011 . 3)) ((c def c (c (? . 1) q =?)) q (2908 . 3)) ((c def c (c (? . 17) q string-lowercase!)) q (21673 . 3)) ((c def c (c (? . 12) q print-convert-constructor-name)) q (15894 . 3)) ((c def c (c (? . 0) q box/c)) q (4121 . 3)) ((c def c (c (? . 10) q pregexp-match-positions)) q (16913 . 15)) ((c form c (c (? . 4) q let+)) q (6856 . 11)) ((c form c (c (? . 11) q match-lambda*)) q (12016 . 2)) ((q def ((lib "mzlib/sandbox.rkt") make-evaluator)) q (19070 . 15)) ((c form c (c (? . 4) q evcase)) q (6665 . 3)) ((c def c (c (? . 18) q call-with-input-file*)) q (7831 . 5)) ((c def c (c (? . 19) q transcript-off)) q (24158 . 2)) ((c def c (c (? . 17) q eval-string)) q (21865 . 6)) ((q def ((lib "mzlib/sendevent.rkt") send-event)) q (19865 . 14))))
syntax
(awk next-record-expr
     (record field-id ...)
     maybe-counter
     ((state-variable init-expr) ...)
     maybe-continue
  clause ...)
 
  maybe-counter = 
                | id
                   
 maybe-continue = 
                | id
                   
         clause = (test body ...+)
                | (test => procedure-expr)
                | (/ regexp-str / (id-or-false ...+) body ...+)
                | (range excl-start-test excl-stop-test body ...+)
                | (:range incl-start-test excl-stop-test body ...+)
                | (range: excl-start-test incl-stop-test body ...+)
                | (:range: incl-start-test incl-stop-test body ...+)
                | (else body ...+)
                | (after body ...+)
                   
           test = integer
                | regexp-string
                | expr
                   
excl-start-test = test
                   
 excl-stop-test = test
                   
incl-start-test = test
                   
 incl-stop-test = test
                   
    id-or-false = id
                | #f
procedure
(match:start rec [which]) -> exact-nonnegative-integer?
  rec : ....
  which : exact-nonnegative-integer? = 0
procedure
(match:end rec [which]) -> exact-nonnegative-integer?
  rec : ....
  which : exact-nonnegative-integer? = 0
procedure
(match:substring rec [which]) -> string?
  rec : ....
  which : exact-nonnegative-integer? = 0
procedure
(regexp-exec re s) -> (or/c .... false/c)
  re : (or/c string? regexp?)
  s : string?
syntax
(command-line program-name-expr argv-expr clause ...)
 
     clause = (multi flag-spec ...)
            | (once-each flag-spec ...)
            | (once-any flag-spec ...)
            | (final flag-spec ...)
            | (help-labels string ...)
            | (args arg-formals body-expr ...+)
            | (=> finish-proc-expr arg-help-expr help-proc-expr
                  unknown-proc-expr)
               
  flag-spec = (flags id ... help-str ...+ body-expr ...+)
            | (flags => handler-expr help-expr)
               
      flags = flag-string
            | (flag-string ...+)
               
arg-formals = id
            | (id ...)
            | (id ...+ . id)
procedure
(spawn thunk) -> thread?
  thunk : (-> any)
procedure
(channel) -> channel?
procedure
(channel-recv-evt ch) -> evt?
  ch : channel?
procedure
(channel-send-evt ch v) -> evt?
  ch : channel?
  v : any/c
procedure
(thread-done-evt thd) -> any
  thd : thread?
procedure
(current-time) -> real?
procedure
(time-evt tm) -> evt?
  tm : real?
procedure
(=? n ...+) -> boolean?
  n : number?
procedure
(<? n ...+) -> boolean?
  n : real?
procedure
(>? n ...+) -> boolean?
  n : real?
procedure
(<=? n ...+) -> boolean?
  n : real?
procedure
(>=? n ...+) -> boolean?
  n : real?
procedure
(1+ n) -> number?
  n : number?
procedure
(1- n) -> number?
  n : number?
procedure
(gentmp [base]) -> symbol?
  base : (or/c string? symbol?) = "g"
procedure
(flush-output-port [o]) -> void?
  o : output-port? = (current-output-port)
procedure
(real-time) -> exact-integer?
procedure
(atom? v) -> any
  v : any/c
syntax
(define-structure (name-id field-id ...))
(define-structure (name-id field-id ...)
                  ((init-field-id init-expr) ...))
procedure
(getprop sym property [default]) -> any/c
  sym : symbol?
  property : symbol?
  default : any/c = #f
procedure
(putprop sym property value) -> void?
  sym : symbol?
  property : symbol?
  value : any/c
procedure
(new-cafe [eval-handler]) -> any
  eval-handler : (any/c . -> . any) = #f
syntax
(define/contract id contract-expr init-value-expr)
procedure
(box/c c) -> flat-contract?
  c : flat-contract?
procedure
(vectorof c) -> flat-contract?
  c : flat-contract?
procedure
(vector/c c ...) -> flat-contract?
  c : flat-contract?
syntax
(struct/c struct-id flat-contract-expr ...)
procedure
(build-flat-contract name predicate) -> flat-contract?
  name : symbol?
  predicate : (-> any/c any)
syntax
(-> contract-dom-expr ... any)
(-> contract-dom-expr ... contract-rng-expr)
syntax
(->* (contract-dom-expr ...) ->*rng)
(->* (contract-dom-expr ...) contract-rest-expr ->*rng)
 
->*rng = (contract-rng-expr ...)
       | any
syntax
(opt-> (contract-req-expr ...) (contact-opt-expr ...) any)
(opt-> (contract-req-expr ...) (contact-opt-expr ...) contract-rng-expr)
syntax
(opt->* (contract-req-expr ...) (contact-opt-expr ...) any)
(opt->* (contract-req-expr ...) (contact-opt-expr ...) (contract-rng-expr ...))
syntax
(->d contract-dom-expr ... contract-rng-fun-expr)
syntax
(->d* (contract-dom-expr ...) contract-rng-fun-expr)
(->d* (contract-dom-expr ...) contract-rest-expr contract-rng-fun-expr)
syntax
(->r ([dom-x contract-dom-expr] ...) rng)
(->r ([dom-x contract-dom-expr] ...) rest-x contract-rest-expr rng)
 
rng = any
    | (values contract-expr ...)
    | contract-expr
syntax
(->pp ([dom-x contract-dom-expr] ...) pre-cond-expr any)
(->pp ([dom-x contract-dom-expr] ...)
      pre-cond-expr
      (values [rng-x contract-rng-expr] ...)
      post-cond-expr)
(->pp ([dom-x contract-dom-expr] ...)
      pre-cond-expr
      contract-rng-expr
      rng-x
      post-cond-expr)
syntax
(->pp-rest ([dom-x contract-dom-expr] ...) rest-x rest-contract-expr pre-cond-expr any)
(->pp-rest ([dom-x contract-dom-expr] ...)
           rest-x rest-contract-expr
           pre-cond-expr
           (values [rng-x contract-rng-expr] ...)
           post-cond-expr)
(->pp-rest ([dom-x contract-dom-expr] ...)
           rest-x rest-contract-expr
           pre-cond-expr
           contract-rng-expr
           rng-x
           post-cond-expr)
syntax
(case-> mzlib/contract-arrow-contract-expr ...)
syntax
(object-contract [id mzlib/contract-arrow-contract-expr] ...)
syntax
(begin-lifted expr ...+)
syntax
(begin-with-definitions defn-or-expr ...)
syntax
(define-syntax-set (id ...) defn ...)
syntax
(evcase key-expr (value-expr body-expr ...) ...+)
(evcase key-expr (value-expr body-expr ...) ... [else body-expr ...])
procedure
(identity v) -> any/c
  v : any/c
syntax
(let+ clause body-expr ...+)
 
clause = (val target expr)
       | (rec target expr)
       | (vals (target ...) expr)
       | (recs (target expr) ...)
       | (_ expr ...)
          
target = id
       | (values id ...)
procedure
(loop-until start done? next f) -> void?
  start : any/c
  done? : (any/c . -> . any)
  next : (any/c . -> . any/c)
  f : (any/c . -> . any)
procedure
(namespace-defined? sym) -> boolean?
  sym : symbol?
syntax
(nand expr ...)
syntax
(nor expr ...)
syntax
(opt-lambda formals body ...+)
syntax
(recur id bindings body ...+)
syntax
(rec id value-expr)
(rec (id arg-id ...) expr)
(rec (id arg-id ... . rest-id) expr)
syntax
(this-expression-source-directory)
(this-expression-source-directory datum)
syntax
(this-expression-file-name)
(this-expression-file-name datum)
syntax
(hash-table (quote flag) ... (key-expr val-expr) ...)
procedure
(call-with-input-file* file proc [mode]) -> any
  file : path-string?
  proc : (input-port? -> any)
  mode : (one-of/c 'text 'binary) = 'binary
procedure
(call-with-output-file*  file         
                         proc         
                        [mode         
                         exists]) -> any
  file : path-string?
  proc : (output-port? -> any)
  mode : (one-of/c 'text 'binary) = 'binary
  exists : (one-of/c 'error 'append 'update
                     'replace 'truncate 'truncate/replace)
         = 'error
procedure
(build-relative-path base sub ...) -> (and/c path? relative-path?)
  base : (or/c path-string?
               (one-of/c 'up 'same))
  sub : (or/c (and/c path-string?
                     relative-path?)
              (one-of/c 'up 'same))
procedure
(build-absolute-path base sub ...) -> (and/c path? absolute-path?)
  base : (or/c (and/c path-string?
                      (not/c relative-path?))
               (one-of/c 'up 'same))
  sub : (or/c (and/c path-string?
                     (not/c complete-path?))
              (one-of/c 'up 'same))
syntax
(include path-spec)
 
path-spec = string
          | (build-path elem ...+)
          | (lib file-string collection-string ...)
             
     elem = string
          | up
          | same
syntax
(include-at/relative-to context source path-spec)
syntax
(include-at/relative-to/reader context source path-spec reader-expr)
syntax
(include/reader path-spec reader-expr)
syntax
(lambda/kw kw-formals body ...+)
syntax
(define/kw (head args) body ...+)
 
    kw-formals = id
               | (id ... [#:optional optional-spec ...]
                         [#:key key-spec ...]
                         [rest/mode-spec ...])
               | (id ... . id)
                  
 optional-spec = id
               | (id default-expr)
                  
      key-spec = id
               | (id default-expr)
               | (id keyword default-expr)
                  
rest/mode-spec = #:rest id
               | #:other-keys id
               | #:other-keys+body id
               | #:all-keys id
               | #:body kw-formals
               | #:allow-other-keys
               | #:forbid-other-keys
               | #:allow-duplicate-keys
               | #:forbid-duplicate-keys
               | #:allow-body
               | #:forbid-body
               | #:allow-anything
               | #:forbid-anything
                  
          head = id
               | (head . kw-formals)
procedure
(keyword-get args kw not-found) -> any
  args : (listof (cons/c keyword? any/c))
  kw : keyword?
  not-found : (-> any)
procedure
(first v) -> any/c
  v : pair?
procedure
(second v) -> any/c
  v : (and/c pair? ....)
procedure
(third v) -> any/c
  v : (and/c pair? ....)
procedure
(fourth v) -> any/c
  v : (and/c pair? ....)
procedure
(fifth v) -> any/c
  v : (and/c pair? ....)
procedure
(sixth v) -> any/c
  v : (and/c pair? ....)
procedure
(seventh v) -> any/c
  v : (and/c pair? ....)
procedure
(eighth v) -> any/c
  v : (and/c pair? ....)
procedure
(rest v) -> any/c
  v : pair?
procedure
(last-pair v) -> pair?
  v : pair?
procedure
(merge-sorted-lists lst1 lst2 less-than?) -> list?
  lst1 : list?
  lst2 : lst?
  less-than? : (any/c any/c . -> . any/c)
procedure
(mergesort lst less-than?) -> list?
  lst : list?
  less-than? : (any/c any/c . -> . any/c)
procedure
(quicksort lst less-than?) -> list?
  lst : list?
  less-than? : (any/c any/c . -> . any/c)
syntax
(match val-expr clause ...)
 
clause = [pat expr ...+]
       | [pat (=> id) expr ...+]
syntax
(define/match (head args) match*-clause ...)
syntax
(match-lambda clause ...)
syntax
(match-lambda* clause ...)
syntax
(match-let ([pat expr] ...) body ...+)
syntax
(match-let* ([pat expr] ...) body ...+)
syntax
(match-letrec ([pat expr] ...) body ...+)
syntax
(match-define pat expr)
syntax
(define-match-expander id proc-expr)
(define-match-expander id proc-expr proc-expr)
(define-match-expander id proc-expr proc-expr proc-expr)
parameter
(match-equality-test) -> (any/c any/c . -> . any)
(match-equality-test comp-proc) -> void?
  comp-proc : (any/c any/c . -> . any)
value
e : real?
procedure
(gethostname) -> string?
procedure
(getpid) -> exact-integer?
procedure
(truncate-file file [n-bytes]) -> void?
  file : path-string?
  n-bytes : exact-nonnegative-integer? = 0
parameter
(abbreviate-cons-as-list) -> boolean?
(abbreviate-cons-as-list abbreviate?) -> void?
  abbreviate? : any/c
parameter
(booleans-as-true/false) -> boolean?
(booleans-as-true/false use-name?) -> void?
  use-name? : any/c
parameter
(use-named/undefined-handler) -> (any/c . -> . any/c)
(use-named/undefined-handler use-handler) -> void?
  use-handler : (any/c . -> . any/c)
parameter
(named/undefined-handler) -> (any/c . -> . any/c)
(named/undefined-handler use-handler) -> void?
  use-handler : (any/c . -> . any/c)
parameter
(add-make-prefix-to-constructor) -> boolean?
(add-make-prefix-to-constructor add-prefix?) -> void?
  add-prefix? : any/c
procedure
(build-share v) -> ....
  v : any/c
parameter
(constructor-style-printing) -> boolean?
(constructor-style-printing use-constructors?) -> void?
  use-constructors? : any/c
parameter
(current-build-share-hook)
 -> (any/c (any/c . -> . void?)
           (any/c . -> . void?) . -> . any)
(current-build-share-hook hook) -> void?
  hook : (any/c (any/c . -> . void?)
                (any/c . -> . void?) . -> . any)
parameter
(current-build-share-name-hook)
 -> (any/c . -> . (or/c symbol? false/c))
(current-build-share-name-hook hook) -> void?
  hook : (any/c . -> . (or/c symbol? false/c))
parameter
(current-print-convert-hook) -> (any/c (any/c . -> . any/c)
                                       (any/c . -> . any/c)
                                       . -> . any/c)
(current-print-convert-hook hook) -> void?
  hook : (any/c (any/c . -> . any/c)
                (any/c . -> . any/c)
                . -> . any/c)
parameter
(current-read-eval-convert-print-prompt) -> string?
(current-read-eval-convert-print-prompt str) -> void?
  str : string?
procedure
(get-shared share-info [cycles-only?])
 -> (list-of (cons/c symbol? any/c))
  share-info : ....
  cycles-only? : any/c = #f
procedure
(install-converting-printer) -> void?
procedure
(print-convert v [cycles-only?]) -> any/c
  v : any/c
  cycles-only? : any/c = (show-sharing)
procedure
(print-convert-expr share-info        
                    v                 
                    unroll-once?) -> any/c
  share-info : ....
  v : any/c
  unroll-once? : any/c
parameter
(quasi-read-style-printing) -> boolean?
(quasi-read-style-printing on?) -> void?
  on? : any/c
parameter
(show-sharing) -> boolean?
(show-sharing show?) -> void?
  show? : any/c
parameter
(whole/fractional-exact-numbers) -> boolean?
(whole/fractional-exact-numbers whole-frac?) -> void?
  whole-frac? : any/c
value
prop:print-converter : property?
procedure
(print-converter? v) -> any
  v : any/c
procedure
(print-converter-proc v)
 -> (any/c (any/c . -> . any/c) . -> . any/c)
  v : print-converter?
value
prop:print-convert-constructor-name : property?
procedure
(print-convert-named-constructor? v) -> any
  v : any/c
procedure
(print-convert-constructor-name v) -> any
  v : print-convert-named-constructor?
syntax
(define-match-expander id proc-expr)
(define-match-expander id proc-expr proc-expr)
(define-match-expander id proc-expr proc-expr proc-expr)
procedure
(strip-shell-command-start in) -> void?
  in : input-port?
procedure
(pregexp-match  pattern       
                input         
               [start-pos     
                end-pos       
                output-port]) 
 -> (or/c (listof (or/c (cons (or/c string? bytes?)
                              (or/c string? bytes?))
                        false/c))
          false/c)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? false/c) = #f
  output-port : (or/c output-port? false/c) = #f
procedure
(pregexp-match-positions  pattern       
                          input         
                         [start-pos     
                          end-pos       
                          output-port]) 
 -> (or/c (listof (or/c (cons exact-nonnegative-integer?
                              exact-nonnegative-integer?)
                        false/c))
          false/c)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? false/c) = #f
  output-port : (or/c output-port? false/c) = #f
procedure
(pregexp-split  pattern       
                input         
               [start-pos     
                end-pos]) -> (listof (or/c string? bytes?))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? false/c) = #f
procedure
(pregexp-replace pattern input insert) -> (or/c string? bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes?)
  insert : (or/c string? bytes?
                 (string? . -> . string?)
                 (bytes? . -> . bytes?))
procedure
(pregexp-replace* pattern input insert) -> (or/c string? bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes?)
  insert : (or/c string? bytes?
                 (string? . -> . string?)
                 (bytes? . -> . bytes?))
procedure
(restart-mzscheme init-argv             
                  adjust-flag-table     
                  argv                  
                  init-namespace)   -> boolean?
  init-argv : (vectorof string?)
  adjust-flag-table : (any/c . -> . any/c)
  argv : (vectorof string?)
  init-namespace : (-> any)
procedure
(make-evaluator language               
                requires               
                input-program ...) -> (any/c . -> . any)
  language : (or/c module-path?
                   (one-of/c 'r5rs 'beginner 'beginner-abbr
                             'intermediate 'intermediate-lambda 'advanced)
                   (list/c (one-of/c 'special) symbol?)
                   (list/c (one-of/c 'special) symbol?)
                   (cons/c (one-of/c 'begin) list?))
  requires : (or/c (cons/c 'begin list?)
                   (listof (or/c module-path? path?)))
  input-program : any/c
(make-evaluator module-decl) -> (any/c . -> . any)
  module-decl : (or/c syntax? pair?)
procedure
(send-event  receiver-bytes        
             event-class-bytes     
             event-id-bytes        
            [direct-arg-v          
             argument-list])   -> any/c
  receiver-bytes : (lambda (s) (and (bytes? s)
                                    (= 4 (bytes-length s))))
  event-class-bytes : (lambda (s) (and (bytes? s)
                                       (= 4 (bytes-length s))))
  event-id-bytes : (lambda (s) (and (bytes? s)
                                    (= 4 (bytes-length s))))
  direct-arg-v : any/c = (void)
  argument-list : list? = null
syntax
(define-serializable-struct id-maybe-super (field-id ...) maybe-inspector-expr)
syntax
(define-serializable-struct/versions id-maybe-super vers-num (field-id ...)
                                     (other-version-clause ...)
                                     maybe-inspector-expr)
 
      id-maybe-super = id
                     | (id super-id)
                        
maybe-inspector-expr = 
                     | inspector-expr
                        
other-version-clause = (other-vers make-proc-expr
                                   cycle-make-proc-expr)
procedure
(glob->regexp [str                 
               hide-dots?          
               case-sensitive?     
               simple?])       -> (or/c regexp? byte-regexp?)
  str : (or/c string bytes?) = ?
  hide-dots? : any/c = #t
  case-sensitive? : any/c
                  = (eq? (system-path-convention-type)'unix)
  simple? : any/c = #f
procedure
(string-lowercase! str) -> void?
  str : (and/c string? (not/c immutable?))
procedure
(string-uppercase! str) -> void?
  str : (and/c string? (not/c immutable?))
procedure
(eval-string str [err-handler]) -> list?
  str : (or/c string? bytes?)
  err-handler : (or/c false/c              = #f
                      (any/c . -> . any/c)
                      (-> any/c))
procedure
(expr->string expr) -> string?
  expr : any/c
procedure
(read-from-string str [err-handler]) -> any/c
  str : (or/c string? bytes?)
  err-handler : (or/c false/c              = #f
                      (any/c . -> . any/c)
                      (-> any/c))
procedure
(read-from-string-all str [err-handler]) -> list?
  str : (or/c string? bytes?)
  err-handler : (or/c false/c              = #f
                      (any/c . -> . any/c)
                      (-> any/c))
syntax
(copy-struct struct-id struct-expr
             (accessor-id field-expr) ...)
syntax
(define-struct/properties id (field-id ...)
                          ((prop-expr val-expr) ...)
                          maybe-inspector-expr)
 
maybe-inspector-expr = 
                     | expr
syntax
(make-->vector struct-id)
procedure
(consumer-thread f [init]) -> thread? procedure?
  f : procedure?
  init : (-> any) = void
procedure
(run-server  port-no            
             conn-proc          
             conn-timeout       
            [handler            
             listen             
             close              
             accept             
             accept/break]) -> void?
  port-no : (integer-in 1 65535)
  conn-proc : (input-port? output-port? . -> . any)
  conn-timeout : (and/c real? (not/c negative?))
  handler : (exn? . -> . any/c) = void
  listen : ((integer-in 1 65535) (one-of/c 5) (one-of/c #t)
            . -> . listener?)
         = tcp-listen
  close : (listener? . -> . any) = tcp-close
  accept : (listener? . ->* . (input-port? output-port?))
         = tcp-accept
  accept/break : (listener? . ->* . (input-port? output-port?))
               = tcp-accept/enable-break
procedure
(transcript-on filename) -> any
  filename : any/c
procedure
(transcript-off) -> any
syntax
(struct id (field-id ...) omit-decl ...)
 
omit-decl = -type
          | -selectors
          | -setters
          | -constructor
syntax
(struct/ctc id ([field-id contract-expr] ...) omit-decl ...)
 
omit-decl = -type
          | -selectors
          | -setters
          | -constructor
syntax
struct~r
syntax
struct~r/ctc
syntax
struct~s
syntax
struct~s/ctc
